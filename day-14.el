;; -*- lexical-binding: t -*-

(defvar p-rx "p=\\([0-9]\\{1,3\\}\\),\\([0-9]\\{1,3\\}\\)")
(defvar v-rx "v=\\(-?[0-9]\\{1,3\\}\\),\\(-?[0-9]\\{1,3\\}\\)")

(defun match-pair ()
  (cons (read (match-string 1))
	(read (match-string 2))))

(defun read-robots (file)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((robots nil))
      (while (re-search-forward p-rx nil t)
	(let ((p (match-pair)))
	  (re-search-forward v-rx)
	  (push (cons p (match-pair)) robots)))
      (nreverse robots))))

(defun simulate1 (r bounds)
  (pcase-let ((`(,bx . ,by) bounds)
	      (`((,rx . ,ry) ,rvx . ,rvy) r))
    (let ((rp (car r)))
      (setcar rp (mod (+ rx rvx) bx))
      (setcdr rp (mod (+ ry rvy) by)))))

(defun simulate (robots bounds secs)
  (dotimes (_ secs)
    (dolist (r robots)
      (simulate1 r bounds))))

(defun quarter (bounds)
  (let* ((x (car bounds))
	 (y (cdr bounds))
	 (x‾ (/ (1- x) 2))
	 (y‾ (/ (1- y) 2)))
    (list (cons (cons 0 x‾)
		(cons 0 y‾))
	  (cons (cons (1+ x‾) x)
		(cons 0 y‾))
	  (cons (cons 0 x‾)
		(cons (1+ y‾) y))
	  (cons (cons (1+ x‾) x)
		(cons (1+ y‾) y)))))

(defun inside (r q)
  (pcase-let ((`((,rx . ,ry)) r)
	      (`((,qx1 . ,qx2) ,qy1 . ,qy2) q))
    (and (>= rx qx1) (< rx qx2)
	 (>= ry qy1) (< ry qy2))))

(defun safety-factor (robots bounds)
  (let ((factor 1))
    (dolist (q (quarter bounds))
      (let ((n 0))
	(dolist (r robots)
	  (when (inside r q)
	    (setq n (1+ n))))
	(setq factor (* factor n))))
    factor))

(defun puzzle-14a ()
  (let ((robots (read-robots "data/input-14.txt"))
	(bounds '(101 . 103)))
    (simulate robots bounds 100)
    (safety-factor robots bounds)))

(defun make-grid (h w &optional blank)
  (let ((g (make-vector h nil)))
    (dotimes (i h)
      (aset g i (make-vector w (or blank ?.))))
    g))

(defun grid-height (g)
  (length g))

(defun grid-width (g)
  (length (aref g 0)))

(defun insert-grid (g)
  (seq-do (lambda (r) (seq-do #'insert r) (insert ?\n)) g))

(defun gset (g i j v)
  "Ignores out-of-bounds references"
  (when (and (>= i 0) (< i (length g)))
    (let ((r (aref g i)))
      (when (and (>= j 0) (< j (length r)))
	(aset r j v)))))

(defun gref (g i j)
  "Returns nil for out-of-bounds references"
  (when (and (>= i 0) (< i (length g)))
    (let ((r (aref g i)))
      (when (and (>= j 0) (< j (length r)))
	(aref r j)))))

(defun reset-grid (g)
  (dotimes (i (grid-height g))
    (dotimes (j (grid-width g))
      (gset g i j ?.))))

(defun robot-grid (g robots)
  (dolist (r robots)
    (gset g (cdar r) (caar r) ?X)))

(defun suspicious-p (g n)
  (catch :suspicious
    (dotimes (i (grid-height g))
      (let ((last nil))
	(dotimes (j (grid-width g))
	  (cond ((eq (gref g i j) ?.)
		 (setq last nil))
		((null last)
		 (setq last j))
		((> (- j last) n)
		 (throw :suspicious t))))))))

(defun watch-robots (g robots bounds times)
  (let* ((again t)
	 (n 0)
	 (p (make-progress-reporter "Simulating" n times)))
    (while (and again (< n times))
      (reset-grid g)
      (robot-grid g robots)
      (simulate robots bounds 1)
      (when (suspicious-p g 20)
	(setq again nil))
      (setq n (1+ n))
      (progress-reporter-update p n))
    (progress-reporter-done p)
    (and (< n times) g)))

(defun puzzle-14b ()
  (let* ((robots (read-robots "data/input-14.txt"))
	 (bounds '(101 . 103))
	 (g (make-grid (cdr bounds) (car bounds))))
    (when-let* ((x (watch-robots g robots bounds 10000)))
      (insert-grid x))))
