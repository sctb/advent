;; -*- lexical-binding: t -*-

(defvar p-rx "p=\\([0-9]\\{1,3\\}\\),\\([0-9]\\{1,3\\}\\)")
(defvar v-rx "v=\\(-?[0-9]\\{1,3\\}\\),\\(-?[0-9]\\{1,3\\}\\)")

(defun match-pair ()
  (cons (read (match-string 1))
	(read (match-string 2))))

(defun read-robots (file)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((robots nil))
      (while (re-search-forward p-rx nil t)
	(let ((p (match-pair)))
	  (re-search-forward v-rx)
	  (push (cons p (match-pair)) robots)))
      (nreverse robots))))

(defun simulate1 (r bounds)
  (pcase-let ((`(,bx . ,by) bounds)
	      (`((,rx . ,ry) ,rvx . ,rvy) r))
    (let ((rp (car r)))
      (setcar rp (mod (+ rx rvx) bx))
      (setcdr rp (mod (+ ry rvy) by)))))

(defun simulate (robots bounds secs)
  (dotimes (_ secs)
    (dolist (r robots)
      (simulate1 r bounds))))

(defun quarter (bounds)
  (let* ((x (car bounds))
	 (y (cdr bounds))
	 (x‾ (/ (1- x) 2))
	 (y‾ (/ (1- y) 2)))
    (list (cons (cons 0 x‾)
		(cons 0 y‾))
	  (cons (cons (1+ x‾) x)
		(cons 0 y‾))
	  (cons (cons 0 x‾)
		(cons (1+ y‾) y))
	  (cons (cons (1+ x‾) x)
		(cons (1+ y‾) y)))))

(defun inside (r q)
  (pcase-let ((`((,rx . ,ry)) r)
	      (`((,qx1 . ,qx2) ,qy1 . ,qy2) q))
    (and (>= rx qx1) (< rx qx2)
	 (>= ry qy1) (< ry qy2))))

(defun safety-factor (robots bounds)
  (let ((factor 1))
    (dolist (q (quarter bounds))
      (let ((n 0))
	(dolist (r robots)
	  (when (inside r q)
	    (setq n (1+ n))))
	(setq factor (* factor n))))
    factor))

(defun puzzle-14a ()
  (let ((robots (read-robots "data/example-14.txt"))
	(bounds '(11 . 7)))
    (let ((robots (read-robots "data/input-14.txt"))
	  (bounds '(101 . 103)))
      (simulate robots bounds 100)
      (safety-factor robots bounds))))

