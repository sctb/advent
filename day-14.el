;; -*- lexical-binding: t -*-

(defvar p-rx "p=\\([0-9]\\{1,3\\}\\),\\([0-9]\\{1,3\\}\\)")
(defvar v-rx "v=\\(-?[0-9]\\{1,3\\}\\),\\(-?[0-9]\\{1,3\\}\\)")

(defun match-pair ()
  (cons (read (match-string 1))
	(read (match-string 2))))

(defun read-robots (file)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((robots nil))
      (while (re-search-forward p-rx nil t)
	(let ((p (match-pair)))
	  (re-search-forward v-rx)
	  (push (cons p (match-pair)) robots)))
      (nreverse robots))))

(defun simulate1 (r bounds)
  (pcase-let ((`(,bx . ,by) bounds)
	      (`((,rx . ,ry) ,rvx . ,rvy) r))
    (let ((rp (car r)))
      (setcar rp (mod (+ rx rvx) bx))
      (setcdr rp (mod (+ ry rvy) by)))))

(defun simulate (robots bounds secs)
  (dotimes (_ secs)
    (dolist (r robots)
      (simulate1 r bounds))))

(defun quarter (bounds)
  (let* ((x (car bounds))
	 (y (cdr bounds))
	 (x‾ (/ (1- x) 2))
	 (y‾ (/ (1- y) 2)))
    (list (cons (cons 0 x‾)
		(cons 0 y‾))
	  (cons (cons (1+ x‾) x)
		(cons 0 y‾))
	  (cons (cons 0 x‾)
		(cons (1+ y‾) y))
	  (cons (cons (1+ x‾) x)
		(cons (1+ y‾) y)))))

(defun inside (r q)
  (pcase-let ((`((,rx . ,ry)) r)
	      (`((,qx1 . ,qx2) ,qy1 . ,qy2) q))
    (and (>= rx qx1) (< rx qx2)
	 (>= ry qy1) (< ry qy2))))

(defun safety-factor (robots bounds)
  (let ((factor 1))
    (dolist (q (quarter bounds))
      (let ((n 0))
	(dolist (r robots)
	  (when (inside r q)
	    (setq n (1+ n))))
	(setq factor (* factor n))))
    factor))

(defun puzzle-14a ()
  (let (;; (robots (read-robots "data/example-14.txt"))
	;; (bounds '(11 . 7))
	(robots (read-robots "data/input-14.txt"))
	(bounds '(101 . 103)))
    (simulate robots bounds 100)
    (safety-factor robots bounds)))

(defun symmetrical-p (robots bounds)
  (let* ((x (car bounds))
	 (x‾ (/ (1- x) 2))
	 (track (make-hash-table)))
    (dolist (r robots)
      (pcase-let ((`((,rx . ,ry)) r))
	(let* ((rx (abs (- x‾ rx)))
	       ;; generate a unique key for each (x, y) point
	       ;; reflected around the x midpoint
	       (key (+ rx (* ry x))))
	  (when (> rx 0) 		; center is always symmetrical
	    (if (gethash key track)
		;; remove symmetrical points from the tracking table
		(remhash key track)
	      (puthash key t track))))))
    (= (hash-table-count track) 0)))

(defun puzzle-14b ()
  (let* ((robots (read-robots "data/input-14.txt"))
	 (bounds '(101 . 103))
	 (i 0)
	 (max 10000000)
	 (p (make-progress-reporter "Simulating" i max)))
    (while (and (< i max) (not (symmetrical-p robots bounds)))
      (simulate robots bounds 1)
      (setq i (1+ i))
      (progress-reporter-update p i))
    (progress-reporter-done p)
    (and (< i max) i)))

(defun convert-robots ()
  (interactive)
  (while (re-search-forward p-rx nil t)
    (replace-match "{\\1, \\2},")
    (re-search-forward v-rx)
    (replace-match "{\\1, \\2}")))
