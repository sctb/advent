;; -*- lexical-binding: t -*-

(defvar rule-rx "\\([0-9]\\{2\\}\\)|\\([0-9]\\{2\\}\\)$")
(defvar update-rx "\\([0-9]\\{2\\},?\\)+")

(defun read-print-queue (file)
  (let ((rules nil)
	(updates nil))
    (with-temp-buffer
      (insert-file-contents file)
      (while (re-search-forward rule-rx nil t)
	(let ((p1 (read (match-string 1)))
	      (p2 (read (match-string 2))))
	  (push (cons p1 p2) rules)))
      (re-search-forward "^$")
      (forward-line)
      (while (looking-at update-rx)
	(let* ((line (buffer-substring (point) (line-end-position)))
	       (split (split-string line ","))
	       (update (mapcar #'read split)))
	  (push update updates))
	(forward-line)))
    (cons (nreverse rules) (nreverse updates))))

(defun middle (pages)
  (let* ((l (length pages))
	 (n (floor l 2)))
    (nth n pages)))

(defun priors (p rules)
  (let ((rules (seq-filter (lambda (r) (eq p (cdr r))) rules)))
    (mapcar #'car rules)))

(defun check-update (u rules)
  (catch :disordered
    (let ((nope (make-hash-table)))
      (dolist (p u)
	(when (gethash p nope)
	  (throw :disordered nil))
	;; cannot print any pages which must come before
	(dolist (r (priors p rules))
	  (puthash r t nope)))
      (middle u))))

(defun puzzle-5a ()
  (let* ((queue (read-print-queue "data/input-5.txt"))
	 (rules (car queue))
	 (updates (cdr queue))
	 (sum 0))
    (dolist (u updates)
      (when-let* ((n (check-update u rules)))
	(setq sum (+ sum n))))
    sum))

(defun ruled-by (u rules)
  (seq-filter (lambda (r)
		(and (memq (car r) u)
		     (memq (cdr r) u)))
	      rules))

(defun blocked (p rules sorted)
  (catch :blocked
    (dolist (r (priors p rules))
      (unless (memq r sorted)
	(throw :blocked t)))))

(defun sort-update (u rules)
  (let ((sorted nil)
	(waiting nil)
	(rules (ruled-by u rules))
	(ordered t))
    (dolist (p u)
      (let ((again t))
	(if (blocked p rules sorted)
	    (progn
	      (push p waiting)
	      (setq ordered nil))
	  (push p sorted))
	(while again
	  (setq again nil)
	  (dolist (p (reverse waiting))
	    (unless (blocked p rules sorted)
	      (push p sorted)
	      (setq waiting (remq p waiting))
	      (setq again t))))))
    (unless ordered
      (middle sorted))))

(defun puzzle-5b ()
  (let* ((queue (read-print-queue "data/input-5.txt"))
	 (rules (car queue))
	 (updates (cdr queue))
	 (sum 0))
    (dolist (u updates)
      (when-let* ((n (sort-update u rules)))
	(setq sum (+ sum n))))
    sum))
