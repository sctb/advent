;; -*- lexical-binding: t -*-

(defun read-diskmap (file)
  (with-temp-buffer
    (let ((digits nil))
      (insert-file-contents file)
      (while-let ((c (char-after)))
	(unless (eq c ?\n)
	  (let ((n (string-to-number (string c))))
	    (push n digits)))
	(forward-char))
      (nreverse digits))))

(defun parse-diskmap (map)
  (let ((blocks [])
	(id 0)
	(count 0))
    ;; This function is slow to allocate and copy the block vector on
    ;; every iteration. A power-of-two growth strategy should be an
    ;; obvious optimization, but for now just report progress instead.
    (let* ((i 0)
	   (p (make-progress-reporter "Parsing diskmap" i (length map))))
      (dolist (n map)
	(let ((v (make-vector n id)))
	  (setq blocks (vconcat blocks v)))
	(if id
	    (setq id nil)
	  (setq count (+ count 1))
	  (setq id count))
	(setq i (+ i 1))
	(progress-reporter-update p i))
      (progress-reporter-done p))    
    blocks))

(defun print-disk (blocks)
  (let* ((n (length blocks))
	 (s (make-string n ?.)))
    (dotimes (i n)
      (when-let* ((x (aref blocks i)))
	(aset s i (+ x 48))))
    s))

(defun compact-disk (blocks)
  (let ((r (1- (length blocks)))
	(w 0))
    (while (> r w)
      (let ((rb (aref blocks r))
	    (wb (aref blocks w)))
	(when (and rb (null wb))
	  (aset blocks w rb)
	  (aset blocks r nil))
	(when (null rb)
	  (setq r (- r 1)))
	(when wb
	  (setq w (+ w 1)))))
    blocks))

(defun checksum (blocks)
  (let ((sum 0))
    (dotimes (i (length blocks))
      (when-let* ((b (aref blocks i)))
	(setq sum (+ sum (* b i)))))
    sum))

(defun puzzle-9a ()
  (let* ((map (read-diskmap "data/input-9.txt"))
	 (blocks (parse-diskmap map)))
    (compact-disk blocks)
    (checksum blocks)))

(defun span (i blocks)
  (let* ((min i)
	 (max i)
	 (b (aref blocks i)))
    (while (and (> min 0)
		(eq (aref blocks min) b))
      (setq min (- min 1)))
    (when (> min 0)
      (setq min (+ min 1)))
    (while (and (< max (length blocks))
		(eq (aref blocks max) b))
      (setq max (+ max 1)))
    (cons min max)))

(defun first-free (span blocks)
  (catch :free
    (let ((i 0))
      (while (< i (car span))
	(while (aref blocks i)
	  (setq i (+ i 1)))
	(when (>= i (car span))
	  (throw :free nil))
	(let ((a (span i blocks)))
	  (if (>= (span-size a) (span-size span))
	      (throw :free a)
	    (setf i (cdr a))))))))

(defun next-file (i blocks)
  (while (null (aref blocks i))
    (setq i (- i 1)))
  (span i blocks))

(defun span-size (a)
  (- (cdr a) (car a)))

(defun move-file (a b blocks)
  (dotimes (n (span-size a))
    (let* ((ia (+ n (car a)))
	   (ib (+ n (car b)))
	   (x (aref blocks ia)))
      (aset blocks ib x)
      (aset blocks ia nil))))

(defun compact-files (blocks)
  (let ((i (1- (length blocks))))
    (while (> i 0)
      (let* ((r (next-file i blocks))
	     (w (first-free r blocks)))
	(when w
	  (move-file r w blocks))
	(setq i (1- (car r)))))
    blocks))

(defun puzzle-9b ()
  (let* ((map (read-diskmap "data/input-9.txt"))
	 (blocks (parse-diskmap map)))
    (compact-files blocks)
    (print-disk blocks)
    (checksum blocks)))
