;; -*- lexical-binding: t -*-

(defun read-line ()
  (buffer-substring (point) (line-end-position)))

(defun read-codes (file)
  (let ((codes nil))
    (with-temp-buffer
      (insert-file-contents file)
      (while (not (eobp))
	(push (read-line) codes)
	(forward-line)))
    (nreverse codes)))

(defun code-number (code)
  (read (substring code 0 -1)))

(defun numpad (key)
  (pcase key
    (?7 '(0 . 0))
    (?8 '(0 . 1))
    (?9 '(0 . 2))
    (?4 '(1 . 0))
    (?5 '(1 . 1))
    (?6 '(1 . 2))
    (?1 '(2 . 0))
    (?2 '(2 . 1))
    (?3 '(2 . 2))
    (?G '(3 . 0)) ; gap
    (?0 '(3 . 1))
    (?A '(3 . 2))))

(defun dirpad (key)
  (pcase key
    (?G '(0 . 0)) ; gap
    (?^ '(0 . 1))
    (?A '(0 . 2))
    (?< '(1 . 0))
    (?v '(1 . 1))
    (?> '(1 . 2))))

(defun heading (from to)
  (cond ((eq from to) 0)
	((< from to) 1)
	(t -1)))

(defun paths (from to avoid)
  (if (equal from to)
      (list (list ?A))
    (pcase-let ((`(,y . ,x) from))
      (let* ((dy (heading y (car to)))
	     (dx (heading x (cdr to)))
	     (paths nil)
	     (a (cons (+ dy y) x))
	     (b (cons y (+ dx x))))
	(unless (or (equal a from) (equal a avoid))
	  (dolist (path (paths a to avoid))
	    (push (cons (if (> dy 0) ?v ?^) path) paths)))
	(unless (or (equal b from) (equal b avoid))
	  (dolist (path (paths b to avoid))
	    (push (cons (if (> dx 0) ?> ?<) path) paths)))
	paths))))

(defvar seq-memo (make-hash-table))

(defun sequence (seq pad)
  (or (gethash seq seq-memo)
      (let ((seqs (compute seq pad)))
	(puthash seq seqs seq-memo))))

(defun compute (seq pad)
  (let ((seqs nil)
	;; convert to list, start from initial position A
	(seq (cons ?A (append seq nil))))
    (while-let ((a (car seq))
		(b (cadr seq)))
      (let* ((from (funcall pad a))
	     (to (funcall pad b))
	     (avoid (funcall pad ?G))
	     (paths (paths from to avoid)))
	(if (null seqs)
	    (setq seqs paths)
	  (let ((extended nil))
	    (dolist (seq seqs)
	      (dolist (path paths)
		(push (concat seq path) extended)))
	    (setq seqs extended))))
      (setq seq (cdr seq)))
    seqs))

(defun shortest (seqs)
  (let ((len nil))
    (dolist (seq seqs)
      (let ((n (length seq)))
	(when (or (null len) (< n len))
	  (setq len n))))
    (seq-filter (lambda (seq)
		  (eq (length seq) len))
		seqs)))

(defun sequences (seqs pad)
  (let ((all nil))
    (dolist (seq seqs)
      (dolist (seq (sequence seq pad))
	(push seq all)))
    (shortest all)))

(defun chain (code n)
  (let ((seqs (sequence code #'numpad)))
    (dotimes (_ n)
      (setq seqs (sequences seqs #'dirpad)))
    (car seqs)))

(defun puzzle-21a ()
  (let ((codes (read-codes "data/input-21.txt"))
	(seq-memo (make-hash-table))
	(sum 0))
    (dolist (code codes)
      (let* ((presses (chain code 2))
	     (complexity (* (code-number code) (length presses))))
	(setq sum (+ sum complexity))))
    sum))

(defun puzzle-21b ()
  (let ((codes (read-codes "data/example-21.txt"))
	(seq-memo (make-hash-table))
	(sum 0))
    (dolist (code codes)
      (let* ((presses (chain code 4))
	     (complexity (* (code-number code) (length presses))))
	(setq sum (+ sum complexity))))
    sum))
