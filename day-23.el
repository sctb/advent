;; -*- lexical-binding: t -*-

(defun read-line ()
  (buffer-substring (point) (line-end-position)))

(defun read-connections (file)
  (let ((connections nil))
    (with-temp-buffer
      (insert-file-contents file)
      (while (not (eobp))
	(let* ((line (read-line))
	       (split (split-string line "-"))
	       (conn (cons (car split) (cadr split))))
	  (push conn connections))
	(forward-line)))
    (nreverse connections)))

(defun connected-p (a b table)
  (member b (gethash a table)))

(defun pairs (cs table)
  (let ((ps nil)
	(a (car cs))
	(bs (cdr cs)))
    (unless (null bs)
      (dolist (b bs)
	(when (connected-p a b table)
	  (push (cons a b) ps)))
      (dolist (p (pairs bs table))
	(push p ps)))
    ps))

(defun tee-p (a)
  (eq (elt a 0) ?t))

(defun counted-p (a b)
  (and (tee-p b) (> (elt a 1) (elt b 1))))

(defun three-sets (table)
  (let ((count 0))
    (maphash
     (lambda (a cs)
       (when (tee-p a)
	 (let ((ps (pairs cs table))
	       (n 0))
	   (dolist (p ps)
	     (unless (or (counted-p a (car p))
			 (counted-p a (cdr p)))
	       (setq n (1+ n))))
	   (setq count (+ count n)))))
     table)
    count))

(defun load-connections (xs table)
  (dolist (x xs)
    (let* ((a (car x))
	   (b (cdr x))
	   (as (gethash a table))
	   (bs (gethash b table)))
      (push b as)
      (push a bs)
      (puthash a as table)
      (puthash b bs table))))

(defun cluster (cs min table)
  (unless (< (length cs) min)
    (let ((cluster (list (car cs))))
      (dolist (b (cdr cs))
	(when (seq-every-p (lambda (c)
			     (connected-p b c table))
			   cluster)
	  (push b cluster)))
      (let* ((n (length cluster))
	     (min (max min n))
	     (other (cluster (cdr cs) min table)))
	(if (> (length other) n)
	    other
	  cluster)))))

(defun lan-party (table)
  (let ((size 0)
	(party nil))
    (maphash
     (lambda (a cs)
       (let ((cs (cluster cs size table)))
	 (when (>= (length cs) size)
	   (setq party (cons a cs))
	   (setq size (length party)))))
     table)
    party))

(defun print-party (party)
  (string-join (sort party) ","))

(defun puzzle-23a ()
  (let* ((file "data/input-23.txt")
	 (table (make-hash-table :test 'equal))
	 (xs (read-connections file)))
    (load-connections xs table)
    (three-sets table)))

(defun puzzle-23b ()
  (let* ((file "data/input-23.txt")
	 (table (make-hash-table :test 'equal))
	 (xs (read-connections file)))
    (load-connections xs table)
    (print-party (lan-party table))))
