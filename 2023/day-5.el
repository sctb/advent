;; -*- lexical-binding: t -*-

(defun read-line ()
  (buffer-substring (point) (line-end-position)))

(defun read-list (string)
  (read (concat "(" string ")")))

(defun read-map ()
  (let ((map-rx "\\([a-z]+\\)-to-\\([a-z]+\\) map:"))
    (when (re-search-forward map-rx nil t)
      (let ((ranges nil)
	    (from (match-string 1))
	    (to (match-string 2)))
	(forward-line)
	(let ((line (read-line)))
	  (while (> (length line) 0)
	    (push (read-list line) ranges)
	    (forward-line)
	    (setq line (read-line))))
	(cons (cons from to) ranges)))))

(defun read-almanac (file)
  (with-temp-buffer
    (insert-file-contents file)
    (re-search-forward "seeds: \\(.*\\)")
    (let ((maps nil)
	  (seeds (read-list (match-string 1))))
      (while-let ((map (read-map)))
	(push map maps))
      (cons seeds (nreverse maps)))))

(defun puzzle-5a ()
  (let* ((almanac (read-almanac "data/input-5.txt"))
	 (seeds (car almanac))
	 (maps (cdr almanac))
	 (lowest nil))
    (dolist (seed seeds)
      (dolist (map maps)
	(let ((ranges (cdr map)))
	  (catch :next
	    (dolist (range ranges)
	      (pcase-let ((`(,dst ,src ,len) range))
		(let ((offset (- seed src)))
		  (when (and (>= offset 0) (< offset len))
		    (setq seed (+ dst offset))
		    (throw :next nil))))))))
      (if (null lowest)
	  (setq lowest seed)
	(setq lowest (min seed lowest))))
    lowest))

(defun range (start length)
  (let ((range nil))
    (dotimes (i length)
      (push (+ start i) range))
    (nreverse range)))

(defun seed-list (pairs)
  (let ((seeds nil))
    (while-let ((start (car pairs))
		(length (cadr pairs)))
      (let ((range (range start length)))
	(setq seeds (nconc seeds range)))
      (setq pairs (cddr pairs)))
    seeds))

(defun puzzle-5b ()
  (let* ((almanac (read-almanac "data/input-5.txt"))
	 (seeds (car almanac))
	 (maps (cdr almanac))
	 (lowest nil))
    (dolist (seed (seed-list seeds))
      (dolist (map maps)
	(let ((ranges (cdr map)))
	  (catch :next
	    (dolist (range ranges)
	      (pcase-let ((`(,dst ,src ,len) range))
		(let ((offset (- seed src)))
		  (when (and (>= offset 0) (< offset len))
		    (setq seed (+ dst offset))
		    (throw :next nil))))))))
      (if (null lowest)
	  (setq lowest seed)
	(setq lowest (min seed lowest))))
    lowest))
