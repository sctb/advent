;; -*- lexical-binding: t -*-

(defun read-grid (filename)
  (with-temp-buffer
    (insert-file-contents filename)
    (let* ((w (1- (line-end-position)))
	   (h (line-number-at-pos (1- (point-max))))
	   (g (make-grid h w)))
      (dotimes (i h)
	(let ((s (buffer-substring (point) (line-end-position))))
	  (dotimes (j w)
	    (gset g i j (aref s j)))
	  (forward-line)))
      g)))

(defun make-grid (h w)
  (let ((g (make-vector h nil)))
    (dotimes (i h)
      (aset g i (make-vector w ?.)))
    g))

(defun grid-height (g)
  (length g))

(defun grid-width (g)
  (length (aref g 0)))

(defun insert-grid (g)
  (seq-do (lambda (r) (seq-do #'insert r) (insert ?\n)) g))

(defun gset (g i j v)
  (let ((r (aref g i)))
    (aset r j v)))

(defun gref (g i j)
  "Returns nil for out-of-bounds references"
  (when (and (>= i 0) (< i (length g)))
    (let ((r (aref g i)))
      (when (and (>= j 0) (< j (length r)))
	(aref r j)))))

(defun prospects (i j)
  (list
   (list (list ?M (- i 1) (- j 1))
	 (list ?A (- i 2) (- j 2))
	 (list ?S (- i 3) (- j 3)))
   (list (list ?M (- i 1) j)
	 (list ?A (- i 2) j)
	 (list ?S (- i 3) j))
   (list (list ?M i (- j 1))
	 (list ?A i (- j 2))
	 (list ?S i (- j 3)))
   (list (list ?M (+ i 1) (- j 1))
	 (list ?A (+ i 2) (- j 2))
	 (list ?S (+ i 3) (- j 3)))
   (list (list ?M (- i 1) (+ j 1))
	 (list ?A (- i 2) (+ j 2))
	 (list ?S (- i 3) (+ j 3)))
   (list (list ?M (+ i 1) (+ j 1))
	 (list ?A (+ i 2) (+ j 2))
	 (list ?S (+ i 3) (+ j 3)))
   (list (list ?M (+ i 1) j)
	 (list ?A (+ i 2) j)
	 (list ?S (+ i 3) j))
   (list (list ?M i (+ j 1))
	 (list ?A i (+ j 2))
	 (list ?S i (+ j 3)))))

(defun mark-prospect (g c i j p)
  (gset g i j c)
  (dolist (x p)
    (pcase-let ((`(,c ,i ,j) x))
      (gset g i j c))))

(defun check-prospect (g p)
  (seq-every-p
   (lambda (x)
     (pcase-let ((`(,c ,i ,j) x))
       (eq c (gref g i j))))
   p))

(defun puzzle-4a ()
  (let* ((g (read-grid "data/input-4.txt"))
	 (h (grid-height g))
	 (w (grid-width g))
	 (x (make-grid h w)) 		; debug only
	 (count 0))
    (dotimes (i h)
      (dotimes (j w)
	(when (eq (gref g i j) ?X)
	  (dolist (p (prospects i j))
	    (when (check-prospect g p)
	      (setq count (+ count 1))
	      (mark-prospect x ?X i j p))))))
    count))

(defun xprospects (i j)
  (list
   (list (list ?M (- i 1) (- j 1))
	 (list ?M (+ i 1) (- j 1))
	 (list ?S (- i 1) (+ j 1))
	 (list ?S (+ i 1) (+ j 1)))
   (list (list ?S (- i 1) (- j 1))
	 (list ?M (+ i 1) (- j 1))
	 (list ?S (- i 1) (+ j 1))
	 (list ?M (+ i 1) (+ j 1)))
   (list (list ?M (- i 1) (- j 1))
	 (list ?S (+ i 1) (- j 1))
	 (list ?M (- i 1) (+ j 1))
	 (list ?S (+ i 1) (+ j 1)))
   (list (list ?S (- i 1) (- j 1))
	 (list ?S (+ i 1) (- j 1))
	 (list ?M (- i 1) (+ j 1))
	 (list ?M (+ i 1) (+ j 1)))))

(defun puzzle-4b ()
  (let* ((g (read-grid "data/input-4.txt"))
	 (h (grid-height g))
	 (w (grid-width g))
	 (x (make-grid h w)) 		; debug only
	 (count 0))
    (dotimes (i h)
      (dotimes (j w)
	(when (eq (gref g i j) ?A)
	  (dolist (p (xprospects i j))
	    (when (check-prospect g p)
	      (setq count (+ count 1))
	      (mark-prospect x ?A i j p))))))
    count))
