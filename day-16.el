;; -*- lexical-binding: t -*-

(defun read-grid (file)
  (with-temp-buffer
    (insert-file-contents file)
    (let* ((width (1- (line-end-position)))
	   (height (line-number-at-pos (1- (point-max))))
	   (grid (make-grid height width)))
      (dotimes (i height)
	(let ((row (buffer-substring (point) (line-end-position))))
	  (dotimes (j width)
	    (gset grid (cons i j) (aref row j)))
	  (forward-line)))
      grid)))

(defun make-grid (height width &optional blank)
  (let ((grid (make-vector height nil)))
    (dotimes (i height)
      (aset grid i (make-vector width (or blank ?.))))
    grid))

(defun grid-height (grid)
  (length grid))

(defun grid-width (grid)
  (length (aref grid 0)))

(defun gset (grid pos value)
  "Ignores out-of-bounds references"
  (pcase-let* ((`(,i . ,j) pos))
    (when (and (>= i 0) (< i (length grid)))
      (let ((row (aref grid i)))
	(when (and (>= j 0) (< j (length row)))
	  (aset row j value))))))

(defun gref (grid pos)
  "Returns nil for out-of-bounds references"
  (pcase-let* ((`(,i . ,j) pos))
    (when (and (>= i 0) (< i (length grid)))
      (let ((row (aref grid i)))
	(when (and (>= j 0) (< j (length row)))
	  (aref row j))))))

(defun grid-like (grid &optional blank)
  (make-grid (grid-height grid) (grid-width grid) blank))

(defun copy-grid (grid)
  (let ((new (grid-like grid)))
    (dotimes (i (grid-height new))
      (aset new i (copy-sequence (aref grid i))))
    new))

(defun insert-grid (grid)
  (seq-do (lambda (row)
	    (seq-do #'insert row)
	    (insert ?\n))
	  grid))

(defun map-grid (function grid)
  (dotimes (i (grid-height grid))
    (dotimes (j (grid-width grid))
      (let ((pos (cons i j)))
	(funcall function pos (gref grid pos))))))

(defun find-reindeer (grid)
  (catch :found
    (map-grid (lambda (pos value)
		(when (eq value ?S)
		  (throw :found (list :east 0 pos))))
	      grid)))

(defun find-end (grid)
  (catch :found
    (map-grid (lambda (pos value)
		(when (eq value ?E)
		  (throw :found pos)))
	      grid)))

(defun score (from to)
  (pcase from
    (:west (pcase to (:west 1) (:north 1001) (:south 1001)))
    (:south (pcase to (:south 1) (:east 1001) (:west 1001)))
    (:east (pcase to (:east 1) (:north 1001) (:south 1001)))
    (:north (pcase to (:north 1) (:east 1001) (:west 1001)))))

(defun around (deer)
  (pcase-let ((`(,dir _ (,i . ,j)) deer))
    `(,@(unless (eq dir :west)
	  (list (list :east (cons i (1+ j)))))
      ,@(unless (eq dir :south)
	  (list (list :north (cons (1- i) j))))
      ,@(unless (eq dir :east)
	  (list (list :west (cons i (1- j)))))
      ,@(unless (eq dir :north)
	  (list (list :south (cons (1+ i) j)))))))

(defun passable (tile)
  (or (eq tile ?.) (eq tile ?E)))

(defun moves (grid deer)
  (let ((moves nil))
    (dolist (a (around deer))
      (pcase-let ((`(,to ,pos) a))
	(when (passable (gref grid pos))
	  (pcase-let* ((`(,from ,score) deer))
	    (let ((score (+ score (score from to))))
	      (push (list to score pos) moves))))))
    moves))

(defun step (grid scores deer)
  (pcase-let* ((`(_ ,score ,pos) deer))
    (unless (> score (gref scores pos))
      (gset scores pos score)
      (unless (eq (gref grid pos) ?E)
	(dolist (deer (moves grid deer))
	  (step grid scores deer))))))

(defun puzzle-16a ()
  ;; Needed to set (setq max-lisp-eval-depth 5000) to avoid a stack
  ;; overflow with the larger puzzle input
  (let* ((grid (read-grid "data/input-16.txt"))
	 (scores (grid-like grid (expt 2 32)))
	 (deer (find-reindeer grid))
	 (end (find-end grid)))
    (step grid scores deer)
    (gref scores end)))

(defvar end-token 0)
(defvar end-receipts nil)

(defun finish (score)
  (let* ((token (setq end-token (1+ end-token)))
	 (receipt (cons token score)))
    (push receipt end-receipts)
    receipt))

(defun register (paths pos receipt)
  (gset paths pos (car receipt))
  receipt)

(defun trace (grid scores paths deer)
  (pcase-let* ((`(_ ,score ,pos) deer)
	       (par (gref scores pos)))
    (unless (> score (+ 1000 par))
      (gset scores pos (min score par))
      (if (eq (gref grid pos) ?E)
	  (register paths pos (finish score))
	(let ((best nil))
	  (dolist (deer (moves grid deer))
	    (when-let* ((receipt (trace grid scores paths deer)))
	      (register paths (elt deer 2) receipt)
	      (when (or (null best)
			(< (cdr receipt) (cdr best)))
		(setq best receipt))))
	  best)))))

(defun winners (best)
  (let ((winners nil))
    (dolist (pair end-receipts)
      (unless (> (cdr pair) best)
	(push (car pair) winners)))
    winners))

(defun count-winners (paths best)
  (let ((count 1)
	(winners (winners best)))
    (map-grid (lambda (_ value)
		(when (memq value winners)
		  (setq count (1+ count))))
	      paths)
    count))

(defun puzzle-16b ()
  ;; Needed to set (setq max-lisp-eval-depth 5000) to avoid a stack
  ;; overflow with the larger puzzle input
  (let* ((grid (read-grid "data/input-16.txt"))
	 (scores (grid-like grid (expt 2 32)))
	 (paths (copy-grid grid))
	 (deer (find-reindeer grid))
	 (end (find-end grid))
	 (end-token 0)
	 (end-receipts nil))
    (trace grid scores paths deer)
    (let ((best (gref scores end)))
      (count-winners paths best))))
